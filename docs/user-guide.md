# Установка

## Требования и зависимости

Для сборки и работы средств прямого управления LuNA необходимые следующие зависимости:
- LuNA (см. установку в [официальном репозитории](https://gitlab.ssd.sscc.ru/luna/luna))
    - GNU C++ Compiler (g++)
    - GNU Flex & Bison
    - Python (3+)
    - MPI (MPICH, OpenMPI...)
- Python3-pip
- Pyinstaller (pip package)

Установка всех необходимых зависимостей для дистрибутива Ubuntu

```bash
$ sudo apt update

# Предварительно установить LuNA с необходимыми для нее зависимостями
# ...

$ pip install python3-pip
$ pip install pyinstaller
```

## Сборка исполняемых файлов из исходников


Клонируем [репозиторий](https://github.com/brusN/luna-bundle-prog-generator) и переходим в директорию с ним

```bash
$ git clone https://github.com/brusN/luna-bundle-prog-generator
$ cd luna-bundle-prog-generator
```

Запускаем сборку исполняемых файлов через make

```bash
$ make
```

Если возникли ошибки при сборке, то необходимо убедиться, что все требуемые зависимости установлены и повторить попытку, предварительно выполнив следующую команду

```
$ make clean
$ make
```


## Добавление собраных исполняемых файлов в PATH

После успешной сборки языковых средств, необходимо добавить папку bin данного репозитория в PATH: 

```bash
# Добавить данный кусок кода, например, в ~/.bashrc
# Например, export LUNA_BUNDLE_HOME=/home/brusn/Repositories/luna-bundle-prog-generator
$ export LUNA_BUNDLE_HOME=*path_to_luna_bundle_repository*/bin
$ export PATH=$LUNA_BUNDLE_HOME/bin:$PATH
```

Для проверки доступности языковых средств, необходимо выполнить в терминале следующие команды:
 
```bash
$ which luna-bundle-parser  
$ which luna-mpi-generator 
```

# Теория

## Прямое управление исполнением программы. Понятие свертки.

Прямое управление исполнением параллельных программ подразумевает возможность вручную задать распределение ресурсов вычислительной системы на ее узлы и порядок исполнения программы. Такая заданая конфигурация исполнения называется **сверткой**. 

Таким образом, программист, описав оптимальную свертку, в теории может повысить эффективность исполнения программы в системе LuNA. Под оптимальной сверткой имеется ввиду свертка, которая обеспечивает требуемую производительность.

## Требования к разрабатываемым средствам

- Управление исполнением программы описывается на высокоуровневом языке.
- С помощью высокоуровнего языка можно описать распределение ресурсов вычислительной системы и определить порядок исполнения программы.


## Функциональность

Средства прямого управления исполнением на данный момент LuNA-программ обладают следующей функциональностью:

- Определение фрагмента данных
- Пересылка фрагмента данных между узлами	
- Исполнение фрагмента вычислений на определенном узле

В процессе разработки данный список может изменяться в зависимости от требований.

## Суть работы средств прямого управления исполнением LuNA-программ

Суть заключается в следующем: так как LuNA основана на MPI, то при наличии LuNA-программы и описанной для нее свертки, при помощи языковых средств можно сгенерировать аналогичную MPI-программу с заданным распределение ресурсов согласно свертке. Сгенерированную MPI-программу можно скомпилировать в исполняемый файл и исполнить. 

Данные языковые средства является опциональными — они не призваны заменить традиционное написание LuNA-программ. При желании программиста они позволяют добиться требуемой эффективности, но не гарантируют ее.

# Опции запуска, входные и выходные данные

СПУ представлены утилитой **luna-mpi-generator**, который использует утилиту **luna-bundle-parser** для генерации промежуточного состояния свертки.

Входные данные:
- Файл с описанной сверткой (например, bundle.bndl)
- Файл с LuNA-программой (например, ../prog/test.fa)
- Файл с описанными атомарными фрагментами кода (../prog/ucodes.cpp)
- Дополнительные опции (о них позже)

Выходные данные:
- Если задана опция buildOnly со значением true, то будет сгенерирован исходный код MPI-программы без компиляции, иначе будет сгенерирован и скомпилирован исходный код в исполняемый файл.

Входные данные задаются через опции. Есть два варианта:
1. Аргументы заданы в конфигурационном JSON-файле и переданы программе на вход через опцию --config-file. Тогда программа проигнорирует остальые опции и всю информацию будет брать из конфигурационного файла.
2. Аргументы заданы каждый через свою опцию

Для получения описания всех опций запуска, необходимо запустить СПУ с опцией --help:
```bash
$ luna-mpi-generator --help
```

# Язык свертки

## Синтаксис языка свертки и структура файла

Синтаксис языка состоит из двух основных блоков — блок макроопределений и блок исполнения.

- В **блоке макроопределений** описываются текстовые макроконстанты, их можно  использовать для параметризации в блоке исполнения. Данный блок является вспомогательным.

- В **блоке исполнения** последовательно описываются операторы управления исполнением программы. Они представляют собой базовые действия, которые в совокупности составляют функциональность языковых средств. Порядок описания операторов задает порядок исполнения программы. Данный блок является основным блоком — в нем задается распределение ресурсов вычислительной системы. 

Свертка описывается в файле с расширением `.bndl` и имеет следующую структуру:

```
--- Содержимое файла bundle.bndl ---

# Блок макроопределений
define {
    # Определение макроконстант
    # ...
}

# Блок исполнения
execution {
    # Применение операторов управления
    # ...
}
```

>**Примечание.** На данный момент синтаксический анализатор свертки требует, чтобы объявлялись оба блока вне зависимости от их содержимого, и блок макроопределений обязательно должен быть первым. См. структуру файла свертки. 


## Операторы управления исполнением программы


### Оператор define

Данный оператор объявляет фрагмент данных, ссылки которого и его самого можно использовать в фрагментах вычислений. Имеет следующий синтаксис:

```
define df $df_name$;
```

После объявление фрагмента данных в фрагментах вычислений можно обращаться к его ссылкам (например, x[i], x[0], x[0][i][j]).

Примеры: 
```
define df x;
define df y;

...
# Фрагмент вычислений использует объявленный фрагмент данных
...
```

### Оператор send

Данный оператор позволяет отправить копию фрагмента данных с одного узла на другой. Имеет следующий синтаксис:

```
send $df_name$ from $sender_rank$ to $receiver_rank$;
```

Примеры:

```
send x from 0 to 1;
send x[0] from 0 to 1;

# В теле оператора for
send x[i] from i to 0;
```

### Оператор run

Данный оператор предписывает исполнение фрагмента вычислений определенному узлу. Имеет следующий синтаксис:

```
run $cf_name$ from $sender_rank$ to $receiver_rank$;
```

Примеры: 
```
# Примеры применения оператора run
run initDf on rank 0;
run task[0] on rank 0;

# В теле оператора for
run task[i] on rank i; 
```

### Оператор for

Данный оператор позволяет описать задать множество применений других операторов управления за исключением оператора define. Является синтаксическим упрощением и позволяет сократить размер описанной свертки. Имеет следующий синтаксис:

```
for $iterator_name$ = $start_iter_value$ .. $end_iter_value$ {
    # Операторы управления
    ...
}
```

Примеры:

```
for i=0..5 {
    run task[i] on rank i;
}

# Эквивалентно следующему коду
run task[0] on rank 0;
run task[1] on rank 1;
run task[2] on rank 2;
run task[3] on rank 3;
run task[4] on rank 4;
run task[5] on rank 5;
```

```
for i=0..3 {
    for j=1..10 {
        run task[i][j] on rank i;
    }
}
```

Результатом применения данного оператора является развертка цикла и последовательное применение описанных операторов управления в теле оператора for.

# Ограничения 

Программист несет полную ответственность за описанную свертку:
- В случае грамматической ошибки в процессе описания свертки возникнет синтаксическая ошибка, которая приведет к аварийному завершению генерации программы.
- В случае если программист неверно опишет распределение ресурсов вычислительной системы или нарушит информационные зависимости путем неправильного задания порядка исполнения, то сгенерированная программа не гарантует её компиляцию или правильное исполнение, а если компиляция удалась, то не гарантирует отсутствие критических ошибок в процессе исполнения.

Примеры таких ошибок:
```
# Нарушение синтаксиса свертки

<--- Отсутствует блок define

execution {
    run <--- незаконченная синтаксическая конструкция
    send x from 0 to 1 <--- отсутствует ;
                       <--- отправка необъявленного фрагмента вычислений  
}

define { <--- блок define идет вторым после блока execution

}
```

Также есть некоторые ограничения на само описание исполнения программы:
- Нет поддержки выражений (например, нельзя использовать x[1+1*2] или x[i+1])
- Исполнение описывается только для структурированного фрагмента кода main()
- Имена фрагментов вычислений и данных обладают глобальной областью видимости  

>  **Примечание.** На текущий момент отсутствует какой-либо полный анализатор ошибок, но все же обработаны некоторые исключительные ситуации, например, при некорректной передачи аргументов на вход средствам. В дальнейшем рассматривается реализация такого анализатора.

> **Примечание.** Все вышеперечисленные ограничения будут сниматься в процессе разработки. На данный момент средства имеют статус прототипа.

# Пример описанной свертки

```
# Инициализация фрагмента данных, перессылка его копии на другой узел и вывод значения

define {

}

execution {
    define df x;
    run initDf on rank 0;
    send x from 0 to 1;
    run printDfValue on rank 1;
}
```

```
# Свертка для программы умножения частей матриц между собой

define {
    N_CORES = 6;
    N = 49;
}

execution {
    define df matrixA;
    define df matrixB;
    define df resultMatrix;

    for i=1..$N_CORES {
       for j=0..$N {
            run initMatrixA[i][j] on rank i;
            run initMatrixB[i][j] on rank i;
            run mulMatrixs[i][j] on rank i;
       }
    }
}
```