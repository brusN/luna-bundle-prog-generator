# Введение

Данная документация написана к средствам прямого управления (СПУ) исполнением программ для системы LuNA. СПУ представляют собой два программных модуля — модуль парсинга свертки и генерации её промежуточного состояния и модуль генерации исходного кода MPI-программы и её компиляции. 

Суть СПУ для системы LuNA заключается в следующем: так как LuNA использует MPI, то при наличии LuNA-программы и описанной для нее свертки, при помощи языковых средств можно сгенерировать аналогичную MPI-программу с заданным распределение ресурсов согласно свертке. Сгенерированную MPI-программу можно скомпилировать в исполняемый файл и исполнить. 

[Ссылка на репозиторий LuNA](https://gitlab.ssd.sscc.ru/luna/luna)

[Ссылка на репозиторий СПУ](https://github.com/brusN/luna-bundle-prog-generator)

# Установка

Установка описана в [руководстве пользователя](user-guide.md).

# Архитектура кода

Как было сказано ранее, СПУ представляет собой два программных модуля. Основным модулем является второй — он использует внутри себя первый.


## Модуль парсинга свертки и генерации её промежуточного состояния

Первый модуль представляет собой описанную грамматику и основную программу парсинга свертки и генерации её промежуточно состояния. Программный модуль реализован на языке C++ с использованием утилит GNU Flex и GNU Bison.

### Логика работы

1. Программа получает на вход два аргумента — файл с описанной сверткой с расширением *.bndl* и путь к выходному JSON-файлу.
2. Содержимое файла с описанной сверткой обрабатывается методом yyparse(), предоставляемым Bison, согласно описанной грамматике.
3. Результат обработки записывается в объект класса *BundleContainer*.
4. Полученный объект передается на вход генератору JSON.
5. На основе полученного объекта создается промежуточное состояние свертки в формате JSON.

### Входные и выходные данные

Входные данные:
- Относительный путь к файлу с описанной сверткой (например, ../bundle.bndl)
- Относительный путь к выходному JSON-файлу, представляющему собой промежуточное состояние свертки (например, output.json)

Выходные данные:
- Промежуточное состояние свертки в JSON-файле, который распологается по пути, указанном во втором аргументе  

### Структура кода

Весь исходный код модуля хранится в директории *bundle2json-parser/src* в корне репозитория СПУ. Исходный код включает в себя описанный алфавит языка свертки, его грамматику, основную программу-парсер и библиотеку к ней. 

### Алфавит языка свертки

Алфавит языка свертки описан в файле [lexer.l](../bundle2json-parser/src/lexer.l), за лексический анализ отвечает утилита GNU Flex. В этой файле определены лексемы, используемые в грамматике. Для расширения алфавита необходимо добавить между символами %% новую лексему: задать регулярное выражение для её распознования, описать действие с ней и добавить новый токен в грамматику (об этом позже). что лексемы должны Ниже приведены некоторые лексемы алфавита свертки: 

```
%%
"define"                      { return KW_DEFINE; }
"df"                          { return KW_DF; }
"execution"                   { return KW_EXECUTION; }

[0-9]+                        { yylval = std::string(yytext); return NUMBER; }
[A-Za-z_][A-Za-z0-9_]*        { yylval = std::string(yytext); return VARIABLE; }

[ \n\t]                       {}
.                             {}
%%
```

> **Примечание.** Переменная yytext в GNU Flex содержит текущий лексемный токен, который был распознан согласно одному из регулярных выражений. Она является указателем на строку, содержащую символы текущего токена. Переменная yyval содержит значение текущего токена, которое может быть использовано в синтаксическом анализаторе. Она может быть использована для хранения значения чисел, строк и других типов данных. 

> **Внимание!** При добавлении новой лексемы следует учесть, что соответствующее ей регулярное правило должно не конфликтовать с остальными, в противном случае возникает неопределенное поведение. 

### Грамматика языка свертки

Грамматика языка свертки описана в файле [grammar.ypp](../bundle2json-parser/src/grammar.ypp), за синтаксический анализ отвечает утилита GNU Bison. В этом файле определены правила грамматики, по которым определяется синтаксис языка свертки. В этом файле объявляются все используемые токены для грамматики, которые определяются, как ранее было сказано, в файле [lexer.l](../bundle2json-parser/src/lexer.l), участок кода, который будет вставлен в файл основной программы и все правила грамматики. 

Синтаксис языка подробно описан в [руководстве пользователя](user-guide.md). Если коротко, он состоит из двух основных блоков — блок макроопределений и блок исполнения. Для них определены два правила — *define_context* и *execution_context* соответственно. Для расширения грамматики необходимо определить новое правило между символами %%.


```
%%
input: KW_DEFINE LCB define_context RCB KW_EXECUTION LCB execution_context RCB {
     ExecutionContext* mainContext = container.getContextByUUID($7);
     container.setMainContext(mainContext);
};

define_context: %empty | const_def | define_context const_def;

const_def: VARIABLE EQUAL NUMBER SEMICOLON {
     container.registerMacroVar($1, $3);
};

execution_context: 
     %empty {
          ExecutionContext* context = new ExecutionContext();
          std::string uuid = container.registerNewContext(context);
          $$ = uuid;
     } | execution_subblock {
          IExecuteSubblock* block = container.getBlockByUUID($1);
          ExecutionContext* context = new ExecutionContext(); 
          context->addBlock(block);
          std::string uuid = container.registerNewContext(context);
          $$ = uuid;
     } | execution_context execution_subblock {
          ExecutionContext* context = container.getContextByUUID($1);
          IExecuteSubblock* block = container.getBlockByUUID($2);
          context->addBlock(block);
          $$ = $1;
     };

execution_subblock: 
     run_block         { $$ = $1; } 
     | send_block      { $$ = $1; } 
     | define_df_block { $$ = $1; }
     | for_block       { $$ = $1; }
;

...
```

В данном файле определен вставляемый участок С++ кода, в нем определен объект класса *BundleContainer*, который содержит в себе объекты-дескрипторы для различных языковых конструкций (о нем позже). Именно на основе содержимого данного объекта генерируется промежуточное состояние свертки.

```
%{
#include <iostream>
#include <map>
#include <string>
#include "parserlib.h"

#define YYSTYPE std::string

int yylex(void);
int yyerror(char* msg);

BundleContainer container;

%}
```

### Основная программа-парсер

Функция main() определена в файле [parser.cpp](../bundle2json-parser/src/parser.cpp). В ней принимается на вход два имени — имя входного файла с описанной сверткой и имя выходного JSON-файла с промежуточным состояние свертки. В данной функции используется своя библиотека.

### Библиотека к программе-парсеру

Библиотека представляет собой набор исходных файлов, которые по смыслу можно поделить на две части — реализация *BundleContainer* ([parserlib.cpp](../bundle2json-parser/src/parserlib.cpp) и [parserlib.h](../bundle2json-parser/src/parserlib.h)) и реализация JSON-генератора на основе объекта класса *BundleContainer* ([jsonhandler.cpp](../bundle2json-parser/src/jsonhandler.cpp) и [jsonhandler.h](../bundle2json-parser/src/jsonhandler.h)).

В реализации *BundleContainer* описаны классы-дескрипторы для основных конструкций языка свертки и контейнер, хранящий в себе всю информацию об свертке.

В реализации JSON-генератора описан класс, который генерирует JSON-файл на основе объекта класса *BundleContainer*.

## Модуль генерации исходного кода MPI-программы и её компиляции

Второй модуль представляет собой программу на языке Python, собранную в исполняемый файл, которая на основе LuNA-программы и описанной свертки генерирует и компилирует MPI-программу. 

### Входные и выходные данные

Входные данные:
- Файл с описанной сверткой (например, bundle.bndl)
- Файл с LuNA-программой (например, ../prog/test.fa)
- Файл с описанными атомарными фрагментами кода (../prog/ucodes.cpp)
- Дополнительные опции (о них позже)

Выходные данные:
- Если задана опция buildOnly со значением true, то будет сгенерирован исходный код MPI-программы без компиляции, иначе будет сгенерирован и скомпилирован исходный код в исполняемый файл.

Входные данные задаются через опции. Есть два варианта:
1. Аргументы заданы в конфигурационном JSON-файле и переданы программе на вход через опцию --config-file. Тогда программа проигнорирует остальые опции и всю информацию будет брать из конфигурационного файла.
2. Аргументы заданы каждый через свою опцию

```python
parser.add_argument('--config-file', dest='config_file_path', type=str, help='Config to config JSON file', default=None)

parser.add_argument('--bundle-file', dest='bundle_file_path', type=str, help='Path to bundle file', default=None)

parser.add_argument('--luna-src', dest='luna_src_path', type=str, help='Path to LuNA program src file', default=None)

parser.add_argument('--cpp-codes', dest='cpp_codes_path', type=str, help='Path to .cpp file with code blocks', default=None)

parser.add_argument('--mpi-header', type=str, help='Including MPI header', default='mpi.h')

parser.add_argument('-o', '--output', dest='output', type=str, help='Path to built binary', default='luna_manual_mpi_program')

parser.add_argument('--buildOnly', action='store_true', help='Just generate MPI src and bundle JSON internal state')
```

Пример конфигурационного файла:
```json
{
  "bundle_file_path": "bundle.bndl",
  "luna_src_path": "prog.fa",
  "cpp_codes_path": "ucodes.cpp",
  "buildOnly": false
}
```

### Логика работы

1. На вход утилите передается через опции либо путь к конфигурационному файлу в формате JSON, либо файл с LuNA-программой, файл с описанными атомарными фрагментами кода и файл с описанной сверткой каждый через отдельную опцию.
2. На основе переданных значений создается объект класса BuildConfig. Он содержит в себе информацию о требуемых для генерации MPI-программы файлов, а также некоторые дополнительные параметры, например, название выходного исполняемого файла или опция сгенерировать программу без компиляции.
3. Далее создается объект класса MPIProgramBuilder, в конструктор которому передается созданный ранее объект класса BuildConfig. Этот класс ответственнен за полный цикл генерации MPI-программы.
4. Запускается его метод *build()*. В этом методе:
     - Компилируется LuNA-программа с опцией --compile-only для получения метаинформации об программе.
     - Файл с описанной сверткой конвертируется в промежуточное состояние в виде JSON-файла при помощи первого модуля.
     - Далее идет парсинг файла program_recom.ja, который был получен в ходе первого шага, из него извлекается информация об всех фрагментах вычислений, связанных с ними фрагментов кода, фрагментов данных, а также фрагментов данных. Вся эта информация записывается в объект класса LunaFragments.
     - После идет последовательная итерация по телу блока execution свертки и генерация соответствующих участков кода для каждого применения оператора управления.
5. Если был установлена опция buildOnly со значением true, то программа завершает свою работу. Если опция отсутствует или имеет значение false, то при помощи объекта класса MPIProgramCompiler происходит компиляция сгенерированной MPI-программы в исполняемый файл. Этот файл можно запустить как любую MPI-программу при помощи mpirun/mpiexec.

## Сборка средств

Сборка СПУ осуществляется при помощи утилиты Make. В ней прописаны все зависимости и последовательная сборка. При добавлении новых файлов с исходным кодом необходимо также добавить их в [Makefile](../Makefile).

